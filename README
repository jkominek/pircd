                                  _                _ 
                           _ __  (_) _ __  ___  __| |
                          | '_ \ | || '__|/ __|/ _` |
                          | |_) || || |  | (__| (_| |  Alpha Five
                          | .__/ |_||_|   \___|\__,_|
    _   _                 |_|    _   _             _   
   | |_| |_  ___   _ __  ___ _ _| | (_)_ _ __   __| |__ _ ___ _ __  ___ _ _  
   |  _| ' \/ -_) | '_ \/ -_) '_| | | | '_/ _| / _` / _` / -_) '  \/ _ \ ' \ 
    \__|_||_\___| | .__/\___|_| |_| |_|_| \__| \__,_\__,_\___|_|_|_\___/_||_|
                  |_|                                                        
                                    by jay kominek (jay.kominek@colorado.edu)


 Yes.
 It really is an IRC daemon.
 Its written in Perl.
 ...
 You can breathe again.
 There. Very good.

*** Introduction

  I suppose I should put a qualifier on that: It is _going_ to be an IRC
daemon.  As of now, it only implements a 'subset' of the IRC protocol.
I'm aiming for compatibility with the Undernet ircd, except where it is
brain damanged. (/umode d+i, for instance, sets you to +id. It should
either ignore the d, or break). Channels, private messages and notices
work well enough.  The biggest things I can think of that it is missing
are inter-server communications and modes (and stuff that follows along
with modes, like the privilages of opers and channel ops). I'm interested
in getting it completely functioning as a stand-alone server first, and
then going for inter-server communications.

  Actually, I've recently been considering developing my own inter-server
protocol.  The state of Undernet should demonstrate nicely that their
inter-server protocol simply isn't cut out to handle the kind of traffic
that they have. The bursting is good, but tokens being sent between
servers might as well be shortened.  Why send 'PRIVMSG' when 'P' is
sufficently unique?  There are a whole lot of four character tokens
which could be cut down to one character.  When you've got 20k people
all talking at each other at once, 3 characters adds up quickly.

*** Functionality

  At the moment, pircd supports the following:

  * PRIVMSG - This works when directed at both other users and channels,
               but no checking (of +n on channels) is done.
  * NOTICE  - The same caveats on PRIVMSG apply here.
  * JOIN    - These all work, except that, again, there is no checking
    CHANNEL   of bans, limits, keys, etc, done when trying to join a
    PART      channel.
  * TOPIC   - Topics can be stored, set and viewed.
  * KICK    - Ops may now kick people out of channels.
  * WHOIS   - This will display most of the information which is actually
              available, and relevent. (nick, user@host, channels,
              away message, server and idle time)
  * WHO     - Works for channels and users, but it doesn't properly handle
              /who'ing a user who happens to be on a channel with you, it
              still displays * over for the channel.
  * ISON    - Works
  * USERHOST- Works, properly handling users that are away.
  * LUSERS  - Its able to provide some of the available information, filling
              in zeros for everything else that is required but it doesn't
              know about.
  * LIST    - This works when provided with a list of channels. It even
              handles topics, even though you can't set them yet. :)
  * TIME    - Works
  * ADMIN   - Works, and the information is now configurable!
  * MOTD    - Works! And you can provide a single line in the configuration,
              or if that single line happens to be a valid file name, it
              uses the contents of the file as the MOTD.
  * MAP     - It works insofar as is possible, but I think it will work
              once inter-server connections can be established, although,
              the output isn't identical to the Undernet ircd's. I figure
              very few clients or programs try parse the output, so
              thats not too much of a concern to me.
  * MODE    - Woo! I've added rudimentary support for modes. Things
              to know about the current state of the modes code:
               1) It checks to make sure its a valid mode change.
               2) Bans, ops and voices are stored, but only ops is
                  actually used.
               3) You can only visibly see the effect of modes in what
                  a channel op is allowed to get away with, and by
                  /whois'ing someone with a voice and op status on
                  a channel.
  * AWAY    - You can set and unset your away message, but it is only
              displayed in /WHOIS output.
  * WALLOPS - Opers can now broadcast messages to everyone who is set +w
  * QUIT    - A very important command. The quit messsage is displayed
              properly to all the channels the person is on.

  * Connections    - pircd implements the anti-spoofing dance in the
              same way as the Undernet ircd does.
  * Disconnections - Either when quitting, pinging out, or breaking the
              connection, the server manages to deallocate the user's
              object... sooner or later.

 Where something says 'works', that means it works insofar as the rest
 of the code allows it to. You can't very well display modes that aren't
 set, or send requests across the network to servers that don't exist.

*** On modes and the implementation thereof...

  In hind sight, writing a whole bunch of code, and then going back and
putting modes in it wasn't the brightest idea I've ever had in my life.
So sue me. (No, wait, don't.) Anyways, going back over all the code and
making it recognize the existance of modes is going to take another version
or two. Here are all the modes that are recognized so far:

 User Modes:

  +o       Users can become opers, and only opers can do wallops.
           Other users can also tell that you're an oper by way of whois.
  +w       If you're +w, you now get to see the oper's wallops.
  +g       God-like operators can see through +s channels
           Other users can tell that an oper is god-like using whois.

 Channel Modes:

  +b       Bans work, and are internally used as regexps, so if you can
           generate a regexp that doesn't use '.'s (since they get translated
           into "\." for proper compatibility) then it will still work as
           a regexp. So you could do \d+ or some such. Thats evil, though,
           so don't do it. :)
  +k       You can set keys, and they work like they should (?)
  +l       You can also set limits, and they should work right, too (?)
  +s       Works in some places, not in others.
  +m       Moderation properly prevents non +v or +o people from talking.
  +n       This keeps people not in the channel from talking into the channel. 
  +t       I think this works too, but I'm look lazy to look. :)

*** On design...

  I've sort of been designing it as I go.  This probably isn't the best
idea in the world, but, ohh well.  It currently has 4 main objects,
'User's, 'Servers's, 'Connection's, and 'Channel's.  Whenever a line
of input comes in from a connection, that socket is checked against
a hash, which is keyed on all local sockets, the corresponding values
are either Server or User objects, both of which have handle methods
on them. $theobject->handle($lineofinput) is then called. User objects
currently dispatch the data by way of a hash of subroutine references
keyed on the name of the command.  I'm trying to go for a scheme whereby
to send something to another thing, you call a method on its object
to 'request' that that object send it to the user which it represents.

*** On versioning...

  Many programs follow a scheme of desigating software alpha and beta
when it is in a non-functional or testing state. I plan on following the
greek letter scheme for the life of this program. Alpha, Beta, Gamma, Delta,
Epsilon, Zeta, Eta, Theta, Iota, Kappa, Lambda, Mu, Nu, Omicron, Pi, Rho,
Sigma, Tau, Upsilon, Phi, Chi, Psi and Omega will be the various versions
of pircd.  Though, I'll use a numeric identifier after that. (Alpha Five,
Delta Three, Omicron Seven, etc).  Many people may see this as silly.
I think its neat. If you want to have your own versioning scheme, go write
your own piece of software.

*** On the author...

  I, Jay Kominek, am majoring in Electrical and Computer Engineering
at the University of Colorado at Boulder.  If you happen to be impressed
with my Perl programming ability (or frightened by it, either one), feel
free to hire me to write some Perl code for you.  I'll work (relativly)
cheap. :)  I also know C, C++ and Java.
  I can be found on the Open Projects IRC Network http://www.openprojects.net/
in #debian using the nick Taliesin.  At least, some times. :)
  Once pircd its a bit more fleshed out, I'll probably set it up somewhere
so that people can check it out without having to run their own copy.

- Jay Kominek <jay.kominek@colorado.edu>
  Hail Eris!
