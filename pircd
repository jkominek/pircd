#!/usr/bin/perl
# 
# pircd
# Created: Mon Sep 14 12:55:01 1998 by jay.kominek@colorado.edu
# Revised: Wed Jun 30 14:50:42 1999 by jay.kominek@colorado.edu
# Copyright 1998 Jay F. Kominek (jay.kominek@colorado.edu)
# 
# Consult the file 'LICENSE' for the complete terms under which you
# may use this file.
#
#####################################################################
# The Perl Internet Relay Chat Daemon
#####################################################################

use strict; # keeps me honest. :)

# Various what-not that we need to get things done.
use POSIX;
use IO::Socket;
use IO::Select;
use Fcntl;
use Tie::RefHash;
use UNIVERSAL qw(isa);

# pircd-specific modules
use Utils;
use Connection;
use User;
use Server;
use LocalServer;
use Channel;

$| = 1;

# We need to be able to use references as the keys to these
#  hashes so that we can iterate over them by their keys, and
#  use the iterative value as the $client object without
#  things breaking.
my %connections = ();
my %ready       = ();
my %unfinished  = ();
tie %connections, 'Tie::RefHash';
tie %ready,       'Tie::RefHash';
tie %unfinished,  'Tie::RefHash';
my $port        = 6667;
my $backlog     = 10;
my $daemon      = 0;
my $conf        = "server.conf";

# Parse the command line
use Getopt::Std;
my %opts;
getopts('dhp:b:f:',\%opts) || &displayhelp;
if(defined($opts{'p'})) { $port    = $opts{'p'}; }
if(defined($opts{'b'})) { $backlog = $opts{'b'}; }
if(defined($opts{'d'})) { $daemon  = 1; }
if(defined($opts{'f'})) { $conf    = $opts{'f'}; }
if(defined($opts{'h'})) { &displayhelp; }
undef %opts;

if($daemon) {
  exit if fork;
  POSIX::setsid() || Utils::syslog('notice',"Cannot start a new session: $!");
}

# Port 6667, with a max of 10 unrecognized connections
#  waiting. That might need to be tunable so that I higher
#  load server doesn't reject connections.
my $server = IO::Socket::INET->new(LocalPort => $port,
				   Listen    => $backlog,
				   Reuse     => 1);
if(!defined($server)) {
  Utils::syslog('err',"Failed to open listening socket on port 6667: %m");
  exit(-1);
}

my $tmp = LocalServer->new($conf);
Utils::servers()->{$tmp->name()} = $Utils::thisserver = $tmp;

my $select    = IO::Select->new($server);
# While we key these on the $client's socket object, we
#  don't have to iterate over them in such as way that they
#  have to be RefHashes
my %inbuffer  = ( );
my %outbuffer = ( );

for(;;) {
  my $client;
  my $time = time();

  foreach $client ($select->can_read(1)) {
    if($client == $server) {
      # Activity on the listening socket means we have a new
      # client attempting to connect.
      my($iaddr,$address,$port,$peer_host,$peer_ip);
      # Get ahold of the new socket, assign it to all the whatnot, etc
      $client = $server->accept;
      $select->add($client);
      &setnonblocking($client);
      $connections{$client} = Connection->new($client,\%outbuffer,$Utils::thisserver);
      $unfinished{$client}  = $connections{$client};
    } elsif(defined($connections{$client})) {
      # It is not the listening socket, so it is probably a client
      my($data,$got);
      $got = $client->recv($data,POSIX::BUFSIZ,0);
      unless(defined $got && length $data) {
	# Aww. We had an error reading from their socket, so we have
	#  to cut them loose.
	if($connections{$client}->isa("User")) {
	  my $user = $connections{$client};
	  $user->quit("Read error to ".$user->nick."[".$user->host."]");
	} elsif($connections{$client}->isa("Server")) {
	  $connections{$client}->squit();
	} else {
	  # Bleh. Too lazy to figure out what to
	  # do about the death of unpromoted Connections.
	  # (actually, we probably don't have to do anything)
	}
      }
      $inbuffer{$client} .= $data;
      # We only want to pass whole lines to the input handling code.
      while($inbuffer{$client} =~ s/(.*\n)$//) {
	unshift(@{$ready{$client}},$1);
      }
    } else {
      # We've got activity on a martian socket!
    }
  }

  # Go through each of the sockets that have full lines
  #  waiting for them..
  foreach $client (keys %ready) {
    my $line;
    # ..and for every line they've got waiting..
    foreach $line (@{$ready{$client}}) {
      my $fu;
      chomp($fu = $line);
      # ..pass it on to the handler for that connection.
      if(defined($connections{$client})) { # it should always be defined
	$connections{$client}->handle($line);
      } else {
	&finishclient($client);
      }
    }
    # and then get rid of the lines.
    delete($ready{$client});
  }

  # This stuff handles testing the connectivity of all the
  #  connections.
  # Here in the first section, we look for anyone who hasn't
  #  been active in the past 90 seconds, and ping at them.
  foreach $client (keys %connections) {
    my $idle = $time - $connections{$client}->last_active();
    if(($idle>90)&&(!$connections{$client}->ping_in_air())) {
      $connections{$client}->ping();
    }
  }

  # And now, if they havn't managed to respond in the past
  #  90 seconds, cut the bums off.
  foreach $client (keys %connections) {
    my $idle = $time - $connections{$client}->last_active();
    if(($idle>180)&&($connections{$client}->ping_in_air())) {
      if($connections{$client}->isa("Server")) {
	$connections{$client}->squit("Ping timeout");
      } else {
	$connections{$client}->quit("Ping timeout");
      }
    }
  }

  # This checks for Connection objects that have finished
  # the little dance to connect. It turns them into Users or
  # Servers, cleans up the old mess, and puts the new object
  # in the right places.
 UNFINISHEDCHECK: foreach $client (keys %unfinished) {
    my $connection = $unfinished{$client};
    # Ask them if they're ready
    if($connection->readytofinalize()) {
      my $thing = $unfinished{$client}->finalize();
      unless(defined($thing)) {
	# finalization falled for some reason. state should be
	# okay, we just need to forget about $client
	&finishclient($client);
	delete($unfinished{$client});
	next UNFINISHEDCHECK;
      }
      if($thing->isa("User")) {
	# They've handed us a User object.
	my $nick = $thing->nick();
	Utils::users()->{$nick} = $thing;
	$connections{$client}   = $thing;
      } elsif($thing->isa("Server")) {
	# They've handed us a Server object.
	my $name = $thing->name();
	Utils::servers()->{$name} = $thing;
	$connections{$client}     = $thing;
      } else {
	# Wow. Martian finalization. Crazy Stuff.
      }
      delete($unfinished{$client});
    }
  }

  # Look to see which of our sockets can be written to at the moment
  foreach $client ($select->can_write(1)) {
    # Skip it if we don't have anything available to send it.
    next unless $outbuffer{$client};
    # Actually attempt to send some of the data.
    my $sent = $client->send($outbuffer{$client},0);
    if(!defined($sent)) { next; }
    # If we couldn't manage to send the whole thing, then trim what we
    #  did manage to send them out of the out-going buffer so we don't
    #  send it again.
    if(($sent==length($outbuffer{$client}))||
       ($!   ==POSIX::EWOULDBLOCK)) {
      substr($outbuffer{$client},0,$sent) = '';
      if(!length($outbuffer{$client})) {
	delete($outbuffer{$client});
      }
    } else {
      # Uhh ohh. We couldn't write to their socket, so we cut them
      #  loose with a Write error signoff message.
      if($connections{$client}->isa("User")) {
	my $user = $connections{$client};
	$user->quit("Write error to ".$user->nick."[".$user->host."]");
      } elsif($connections{$client}->isa("Server")) {
	$connections{$client}->squit();
      } else {
	# Bleh. I'm too lazy to figure out what should be done about
	#  Connection objects. Probably just delete them.
      }
      next;
    }
  }
}

END {
  foreach my $client (keys %connections) {
    &finishclient($client);
  }
}

sub addinitiatedclient {
  my $client = shift;
  my $send   = shift;

  $select->add($client);
  &setnonblocking($client);
  $connections{$client} = Connection->new($client,
					  \%outbuffer,
					  $Utils::thisserver);
  $unfinished{$client}  = $connections{$client};
  $connections{$client}->setinitiated();
  $connections{$client}->senddata($send);
}

sub finishclient {
  my $client = shift;
  my $thing  = $connections{$client};
  # Kill all the buffers, etc for the client.
  delete($ready{$client});
  delete($outbuffer{$client});
  delete($inbuffer{$client});
  if($connections{$client} != undef && 
     $connections{$client}->isa("Connection")) {
    # We deal with Connections
    delete($unfinished{$client});
  }
  # Users and Servers have to take care of themselves, though
  delete($connections{$client});
  # Don't want to wait on the socket any more..
  $select->remove($client);
  # ..because we're closing it.
  close($client);
}

sub setnonblocking {
  my $sock = shift;
  # Get the current state of the socket..
  my $flags = fcntl($sock, F_GETFL, 0) or
    die "Can't get the flags on socket: $!\n";
  # ..and then add O_NONBLOCK (nonblocking-ness) on to it.
  fcntl($sock, F_SETFL, $flags | O_NONBLOCK) or
    die "Can't set socket non-blocking: $!\n";
}

sub displayhelp {
  print "Usage: pircd [OPTION]...
  -p                              Set default listening port   [$port]
  -b                              Set the max incoming backlog [$backlog]
  -f                              Server configuration file    [$conf]
  -d                              Fork and daemonize
  -h                              Display command line option help
";
  exit(1);
}
